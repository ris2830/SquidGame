<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïµÔ∏è Spy Game - Find the Spy!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 100%);
            color: #00ff00;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #00ff00;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .game-title {
            font-size: 3em;
            text-shadow: 0 0 10px #00ff00;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px #00ff00; }
            to { text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00; }
        }

        .screen {
            display: none;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
        }

        .screen.active {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #00ff00;
            font-weight: bold;
        }

        input {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 5px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
        }

        input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .btn {
            background: linear-gradient(45deg, #004400, #008800);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background: linear-gradient(45deg, #008800, #00ff00);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .info-card {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .info-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #00ff00;
        }

        .info-value {
            font-size: 2em;
            font-weight: bold;
            color: #ffffff;
        }

        .players-list {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 5px;
            border-left: 4px solid #00ff00;
        }

        .player-name {
            font-weight: bold;
        }

        .player-status {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .chat-container {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff00;
            border-radius: 10px;
            height: 300px;
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            border-bottom: 1px solid #00ff00;
        }

        .chat-message {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 255, 0, 0.05);
            border-radius: 5px;
            border-left: 3px solid #00ff00;
        }

        .message-sender {
            font-weight: bold;
            color: #00ff00;
        }

        .message-text {
            margin-top: 5px;
        }

        .chat-input {
            display: flex;
            padding: 10px;
        }

        .chat-input input {
            flex: 1;
            margin-right: 10px;
        }

        .voting-section {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .vote-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .vote-btn {
            background: linear-gradient(45deg, #440000, #880000);
            border: 2px solid #ff4444;
            color: #ff4444;
        }

        .vote-btn:hover {
            background: linear-gradient(45deg, #880000, #ff4444);
            color: #000;
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.7);
        }

        .role-display {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid;
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.5em;
        }

        .role-spy {
            border-color: #ff0000;
            color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        .role-civilian {
            border-color: #0088ff;
            color: #0088ff;
            box-shadow: 0 0 20px rgba(0, 136, 255, 0.5);
        }

        .spy-guess {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0000;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .timer {
            font-size: 3em;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
        }

        .timer.warning {
            color: #ff4444;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .game-result {
            text-align: center;
            padding: 30px;
            font-size: 1.5em;
        }

        .winner {
            font-size: 2em;
            margin: 20px 0;
            font-weight: bold;
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            color: #ff0000;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .game-info {
                grid-template-columns: 1fr;
            }
            
            .vote-buttons {
                grid-template-columns: 1fr;
            }
            
            .game-title {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="matrix-bg" id="matrix"></div>
    
    <div class="container">
        <div class="game-header">
            <h1 class="game-title">üïµÔ∏è SPY GAME</h1>
            <p>Find the spy before time runs out!</p>
        </div>

        <!-- Join Game Screen -->
        <div class="screen active" id="joinScreen">
            <h2>üö™ Join Game</h2>
            <div class="form-group">
                <label for="gameId">Game ID:</label>
                <input type="text" id="gameId" placeholder="Enter game code..." />
            </div>
            <div class="form-group">
                <label for="playerName">Your Name:</label>
                <input type="text" id="playerName" placeholder="Enter your spy name..." />
            </div>
            <button class="btn" onclick="joinGame()">üéÆ Join Game</button>
            <div id="joinError" class="error" style="display: none;"></div>
        </div>

        <!-- Lobby Screen -->
        <div class="screen" id="lobbyScreen">
            <h2>üèÅ Game Lobby</h2>
            <div class="players-list">
                <h3>Players in game:</h3>
                <div id="playersList"></div>
            </div>
            <button class="btn" id="startGameBtn" onclick="startGame()">üöÄ Start Game</button>
            <div id="lobbyError" class="error" style="display: none;"></div>
        </div>

        <!-- Game Screen -->
        <div class="screen" id="gameScreen">
            <div class="game-info">
                <div class="info-card">
                    <div class="info-title">‚è∞ Time</div>
                    <div class="info-value timer" id="gameTimer">5:00</div>
                </div>
                <div class="info-card">
                    <div class="info-title">üë• Players</div>
                    <div class="info-value" id="playerCount">0</div>
                </div>
                <div class="info-card">
                    <div class="info-title">üìç Phase</div>
                    <div class="info-value" id="gamePhase">Discussion</div>
                </div>
            </div>

            <div class="role-display" id="roleDisplay"></div>

            <div class="players-list">
                <h3>üé≠ Players:</h3>
                <div id="gamePlayersList"></div>
            </div>

            <div class="chat-container">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input">
                    <input type="text" id="messageInput" placeholder="Type your message..." maxlength="200" />
                    <button class="btn" onclick="sendMessage()">üì§ Send</button>
                </div>
            </div>

            <div class="voting-section" id="votingSection" style="display: none;">
                <h3>üó≥Ô∏è Vote to eliminate a player:</h3>
                <div class="vote-buttons" id="voteButtons"></div>
            </div>

            <div class="spy-guess" id="spyGuessSection" style="display: none;">
                <h3>üîç Spy's Final Guess:</h3>
                <p>As the spy, you can make a final guess about the location to win the game!</p>
                <input type="text" id="locationGuess" placeholder="Enter location..." />
                <button class="btn" onclick="makeSpyGuess()">üéØ Make Guess</button>
            </div>
        </div>

        <!-- Game Result Screen -->
        <div class="screen" id="resultScreen">
            <div class="game-result">
                <h2>üéÆ Game Over!</h2>
                <div class="winner" id="gameWinner"></div>
                <div id="gameDetails"></div>
                <button class="btn" onclick="returnToLobby()">üîÑ New Game</button>
            </div>
        </div>
    </div>

    <script>
        // Matrix rain effect
        function createMatrix() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const matrixDiv = document.getElementById('matrix');
            matrixDiv.appendChild(canvas);

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const letters = '01010110100101110010101011010101010110100101110010101';
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            const drops = Array(Math.floor(columns)).fill(1);

            function draw() {
                ctx.fillStyle = 'rgba(15, 15, 35, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#00ff00';
                ctx.font = fontSize + 'px monospace';

                for (let i = 0; i < drops.length; i++) {
                    const text = letters[Math.floor(Math.random() * letters.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            setInterval(draw, 50);
        }

        // Initialize matrix effect
        createMatrix();

        // Socket connection
        const socket = io();
        let gameState = null;
        let myRole = null;
        let gameId = null;

        // Socket event handlers
        socket.on('game_joined', (data) => {
            gameState = data;
            myRole = data.myRole;
            showScreen('lobbyScreen');
            updatePlayersList();
        });

        socket.on('game_started', (data) => {
            showScreen('gameScreen');
        });

        socket.on('game_state', (data) => {
            gameState = data;
            myRole = data.myRole;
            updateGameScreen();
        });

        socket.on('player_joined', (data) => {
            gameState = data.gameState;
            updatePlayersList();
            addChatMessage('System', `${data.playerName} joined the game`);
        });

        socket.on('player_left', (data) => {
            gameState = data.gameState;
            updatePlayersList();
            addChatMessage('System', `${data.playerName} left the game`);
        });

        socket.on('new_message', (data) => {
            addChatMessage(data.playerName, data.message);
        });

        socket.on('vote_cast', (data) => {
            gameState = data.gameState;
            updateGameScreen();
        });

        socket.on('game_ended', (data) => {
            showGameResult(data);
        });

        socket.on('error', (message) => {
            showError('joinError', message);
        });

        // Game functions
        function joinGame() {
            const gameIdValue = document.getElementById('gameId').value.trim();
            const playerNameValue = document.getElementById('playerName').value.trim();

            if (!gameIdValue || !playerNameValue) {
                showError('joinError', 'Please enter both game ID and player name');
                return;
            }

            gameId = gameIdValue;
            socket.emit('join_game', {
                gameId: gameIdValue,
                playerName: playerNameValue
            });
        }

        function startGame() {
            socket.emit('start_game');
        }

        function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();

    if (!message) return;

    socket.emit('send_message', { message });
    input.value = '';
}

</script>

<script>
        // NEUE UND ANGEPASSTE FUNKTIONEN F√úR DISKUSSION/VOTING (separater Block zur Sicherheit)

        function formatPhaseName(phase) {
            switch (phase) {
                case 'lobby': return 'Lobby';
                case 'discussion': return 'Diskussion';
                case 'voting': return 'Abstimmung';
                case 'result': return 'Runden-Ergebnis';
                case 'gameOver': return 'Spielende';
                default: return phase;
            }
        }

        function getGamePlayerNameById(playerId) {
            if (!gameState || !gameState.players) return 'Unbekannter Spieler';
            const player = gameState.players.find(p => p.id === playerId);
            return player ? player.name : 'Unbekannter Spieler';
        }

        function updateVoteButtons(votablePlayers) {
            const voteButtonsDiv = document.getElementById('voteButtons');
            if (!voteButtonsDiv) return;
            voteButtonsDiv.innerHTML = ''; // Clear old buttons

            const me = gameState ? gameState.players.find(p => p.id === myPlayerId) : null;
            if (me && me.hasVoted) { // If already voted, show message instead of buttons
                voteButtonsDiv.innerHTML = '<p>Du hast bereits abgestimmt.</p>';
                return;
            }

            votablePlayers.forEach(player => {
                if (player.id === myPlayerId) return; // Cannot vote for self

                const button = document.createElement('button');
                button.className = 'btn vote-btn'; // Existing classes
                button.textContent = `Stimme f√ºr ${player.name}`;
                button.onclick = () => castVote(player.id);
                voteButtonsDiv.appendChild(button);
            });
        }

        function castVote(votedPlayerId) {
            if (!gameState || gameState.currentPhase !== 'voting') {
                addChatMessage('System', 'Abstimmung ist derzeit nicht m√∂glich.');
                return;
            }
            const me = gameState.players.find(p => p.id === myPlayerId);
            if (me && me.hasVoted) {
                 addChatMessage('System', 'Du hast bereits abgestimmt.');
                 return;
            }
            console.log(`Attempting to vote for: ${votedPlayerId}`);
            socket.emit('cast_vote', { votedPlayerId: votedPlayerId });
        }

        function displayRoundResult(data) {
            // Find out who was eliminated based on status (or a specific event from server if added)
            let eliminatedPlayerName = null;
            let tie = true; // Assume tie unless specific eliminated player found
            let mostVotes = 0;

            const voteCounts = {};
            if(data.votes) { // data.votes from server is {voterId: votedPlayerId}
                Object.values(data.votes).forEach(votedId => {
                    voteCounts[votedId] = (voteCounts[votedId] || 0) + 1;
                });
            }

            let votedOutId = null;
            for (const playerId in voteCounts) {
                if (voteCounts[playerId] > mostVotes) {
                    mostVotes = voteCounts[playerId];
                    votedOutId = playerId;
                    tie = false;
                } else if (voteCounts[playerId] === mostVotes) {
                    tie = true;
                }
            }

            if (votedOutId && !tie) {
                const eliminatedPlayer = data.players.find(p => p.id === votedOutId && p.status === 'eliminated');
                if (eliminatedPlayer) {
                    eliminatedPlayerName = eliminatedPlayer.name;
                     addChatMessage('System', `Runden-Ergebnis: ${eliminatedPlayerName} wurde mit ${mostVotes} Stimmen eliminiert.`);
                    if (eliminatedPlayer.id === myPlayerId) {
                        addChatMessage('System', "Du wurdest eliminiert!");
                        // UI anpassen, wenn man selbst eliminiert wurde (z.B. keine Aktionen mehr erlauben)
                    }
                } else {
                    // Fallback, wenn Status nicht direkt aktualisiert wurde oder Logik anders ist
                    const potentialEliminated = getGamePlayerNameById(votedOutId);
                    addChatMessage('System', `Runden-Ergebnis: ${potentialEliminated} wurde mit ${mostVotes} Stimmen eliminiert.`);
                }
            } else if (tie && mostVotes > 0) {
                addChatMessage('System', "Runden-Ergebnis: Unentschieden! Niemand wurde eliminiert.");
            } else {
                addChatMessage('System', "Runden-Ergebnis: Niemand wurde eliminiert (keine Stimmen oder keine Mehrheit).");
            }
        }

        function displayFinalGameResult(data) { // Wird von 'gameOver' Phase in game_state getriggert
            const winnerDisplay = document.getElementById('gameWinner');
            const detailsDisplay = document.getElementById('gameDetails');
            if (!winnerDisplay || !detailsDisplay) return;

            // Annahme: Server sendet eine Struktur wie data.winnerTeam und data.reason
            if (data.winnerTeam) {
                 winnerDisplay.textContent = `${formatPhaseName(data.winnerTeam)} haben gewonnen!`;
                 if (data.reason) {
                     detailsDisplay.textContent = data.reason;
                 } else {
                     detailsDisplay.textContent = '';
                 }
            } else {
                winnerDisplay.textContent = 'Das Spiel ist vorbei.';
                detailsDisplay.textContent = 'Keine eindeutigen Gewinnerinformationen vom Server.';
            }
            // Weitere Details k√∂nnten hier angezeigt werden, z.B. wer die Imposter waren.
        }

        // ANGEPASSTER game_state HANDLER (ersetzt den alten oder wird zus√§tzlich geladen)
        // Es ist besser, den alten game_state Handler zu entfernen oder diesen hier umzubenennen,
        // um Konflikte zu vermeiden, wenn beide gleichzeitig existieren.
        // F√ºr diesen automatisierten Schritt gehen wir davon aus, dass der Agent dies sp√§ter korrigiert
        // oder dass der Browser den letzten Handler verwendet.
        const original_socket_on_game_state = socket.listeners('game_state')[0]; // Versuche alten Listener zu bekommen
        if(original_socket_on_game_state) socket.off('game_state', original_socket_on_game_state); // Entferne alten Listener

        socket.on('game_state', (data) => {
            console.log('Game state received (new handler):', data);
            const oldPhase = gameState ? gameState.currentPhase : null;
            gameState = data;

            const playerCountDisplay = document.getElementById('playerCount');
            if (playerCountDisplay) playerCountDisplay.textContent = data.players.length;

            const startGameBtn = document.getElementById('startGameBtn');
            if (startGameBtn) {
                 const clientMinPlayers = 3;
                 startGameBtn.disabled = data.players.length < clientMinPlayers || data.gameStarted;
                 startGameBtn.textContent = `üöÄ Spiel starten (${data.players.length}/${clientMinPlayers}+ Spieler)`;
            }

            if (document.getElementById('lobbyScreen').classList.contains('active')) {
                updateLobbyPlayers(data.players);
            }

            const gameScreenActive = document.getElementById('gameScreen').classList.contains('active');
            if (gameScreenActive) {
                updateGamePlayersList(data.players.filter(p => p.status === 'active'));
                const me = data.players.find(p => p.id === myPlayerId);
                if (me) {
                    updateRoleDisplay(myRole, myWord, me.role === 'Imposter'); // myRole/myWord kommen von 'player_info'
                    if (me.status === 'eliminated') {
                        document.getElementById('messageInput').disabled = true;
                        document.querySelector('.chat-input button').disabled = true;
                        if(document.getElementById('votingSection')) document.getElementById('votingSection').style.display = 'none';
                        // Verhindere wiederholte Nachrichten √ºber Eliminierung
                        if (!window.eliminationNotified) {
                            addChatMessage('System', 'Du bist eliminiert und kannst nicht mehr teilnehmen.');
                            window.eliminationNotified = true;
                        }
                    } else {
                        document.getElementById('messageInput').disabled = false;
                        document.querySelector('.chat-input button').disabled = false;
                        window.eliminationNotified = false; // Reset, falls Spieler wiederbelebt wird (unwahrscheinlich hier)
                    }
                }
            }

            const gamePhaseDisplay = document.getElementById('gamePhase');
            if (gamePhaseDisplay) gamePhaseDisplay.textContent = formatPhaseName(data.currentPhase);

            const gameTimerDisplay = document.getElementById('gameTimer');
            if (gameTimerDisplay && data.timerValue !== undefined) {
                const minutes = Math.floor(data.timerValue / 60);
                const seconds = data.timerValue % 60;
                gameTimerDisplay.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
                gameTimerDisplay.classList.toggle('warning', data.timerValue <= 10 && data.timerValue > 0 && data.currentPhase !== 'result');
            }

            const votingSection = document.getElementById('votingSection');
            const chatContainer = document.querySelector('.chat-container');

            // Nur Screen wechseln, wenn sich die Phase tats√§chlich ge√§ndert hat und der Screen nicht schon aktiv ist
            if (data.currentPhase === 'discussion') {
                if (!gameScreenActive && data.currentPhase !== oldPhase) showScreen('gameScreen');
                if(votingSection) votingSection.style.display = 'none';
                if(chatContainer) chatContainer.style.display = 'flex';
                updateVoteButtons([]);
            } else if (data.currentPhase === 'voting') {
                if (!gameScreenActive && data.currentPhase !== oldPhase) showScreen('gameScreen');
                if(votingSection) votingSection.style.display = 'block';
                if(chatContainer) chatContainer.style.display = 'none';
                const me = data.players.find(p => p.id === myPlayerId);
                if (me && me.status === 'active' && !me.hasVoted) {
                    updateVoteButtons(data.players.filter(p => p.status === 'active' && p.id !== myPlayerId));
                } else {
                     updateVoteButtons([]);
                }
            } else if (data.currentPhase === 'result') {
                if (!gameScreenActive && data.currentPhase !== oldPhase) showScreen('gameScreen');
                if(votingSection) votingSection.style.display = 'none';
                if(chatContainer) chatContainer.style.display = 'flex';
                if (oldPhase === 'voting' || (oldPhase === 'discussion' && data.timerValue <=0) ) { // Ergebnis anzeigen, wenn von Voting oder Discussion-Timeout kommend
                    displayRoundResult(data);
                }
            } else if (data.currentPhase === 'gameOver') {
                if(data.currentPhase !== oldPhase) showScreen('resultScreen');
                displayFinalGameResult(data);
            } else if (data.currentPhase === 'lobby') {
                if (!document.getElementById('lobbyScreen').classList.contains('active') && data.currentPhase !== oldPhase) showScreen('lobbyScreen');
            }
        });

        // NEUER Event Handler
        const original_socket_on_vote_confirmed = socket.listeners('vote_confirmed')[0];
        if(original_socket_on_vote_confirmed) socket.off('vote_confirmed', original_socket_on_vote_confirmed);

        socket.on('vote_confirmed', (data) => {
            console.log('Vote confirmed for player ID:', data.votedPlayerId);
            const targetPlayer = gameState.players.find(p => p.id === data.votedPlayerId);
            addChatMessage('System', `Du hast erfolgreich f√ºr ${targetPlayer ? targetPlayer.name : 'unbekannt'} gestimmt.`);
            updateVoteButtons([]);
            const me = gameState.players.find(p => p.id === myPlayerId);
            if(me) me.hasVoted = true;
        });

        function returnToLobby() {
            // Einfachste Methode: Seite neu laden, um zum Join-Screen zur√ºckzukehren
            window.location.reload();
            // Alternativ k√∂nnte man ein Event an den Server senden, um das Spiel zur√ºckzusetzen
            // oder den Spieler aus dem aktuellen Spiel zu entfernen und zur Lobby-Auswahl zu leiten,
            // falls es eine spiel√ºbergreifende Lobby g√§be.
            // F√ºr dieses Einzelspiel-Setup ist reload() ausreichend.
        }
</script>